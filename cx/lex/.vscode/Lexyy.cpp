/*just for test*/#line 1 "../c.lex"
                                                                              

                                                                            
                                                                             
                                                                         
                                      
   

#include <stdio.h>
#include <string.h>
#include <search.h>	 /* Function prototype for bsearch(). 	*/
#include <tools/debug.h> /* Needed by symtab.h.			*/
#include <tools/hash.h>	 /* Needed by symtab.h.			*/
#include <tools/l.h>
#include <tools/compiler.h>
#include "yyout.h"	/* Token defs. created by occs. Yacc uses y.tab.h. */
#include "symtab.h"	/* Needed to pass attributes to parser.		   */
#include "value.h"	/* ditto					   */

extern union {		      /* This definition must duplicate the %union */
    char	*p_char;      /* in c.y.				     */
    symbol	*p_sym;
    link	*p_link;
    structdef	*p_sdef;
    specifier	*p_spec;
    value	*p_value;
    int		integer;
    int		ascii;
}
yylval;				/* Declared by occs in yyout.c. */

extern FILE *yycodeout;		/* Declared by occs in yyout.c	*/

static int id_or_keyword P(( char *lex ));	/* declared, below */
/*----------------------------------------------------------------------*/

#define YYERROR	yyerror	/* Forces LeX-generated error messages to be     */
			/* output in an occs window if debugging mode    */
			/* is enabled.  Does nothing in UNIX lex. Remove */
			/* this definition if you aren't using occs -d.  */

/*----------------------------------------------------------------------*/










#ifdef _NEVER_
/*---------------------------------------*/* DFA (start state is 0) is:
*
 * State 0 [nonaccepting]
 * goto  0 on \x000\x001\x002\x003\x004\x005\x006\x007\b\t
 * goto  1 on \n
 * goto  0 on \x00b\f\r\x00e\x00f\x010\x011\x012\x013\x014\x015\x016\x017
 *           \x018\x019\x01a\x01b\x01c\x01d\x01e\x01f !"#$%&\'()*+,-./
 *           0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg
 *           hijklmnopqrstuvwxyz{|}~\x07f
 * State 1 [nonaccepting]
 */

#endif

#line 1 "../lex.par"
/*@A (C) 1992 Allen I. Holub                                                */



#line 11 "../lex.par"


/* YY_TTYPE is used for the DFA transition table: Yy_nxt[], declared below.
 * YYF marks failure transitions in the DFA transition table. There's no failure
 * state in the table itself, these transitions must be handled by the driver
 * program. The DFA start state is State 0. YYPRIVATE is only defined here only
 * if it hasn't be #defined earlier. I'm assuming that if NULL is undefined,
 * <stdio.h> hasn't been included.
 */

#ifndef YYPRIVATE
#       define YYPRIVATE static
#endif

#ifndef NULL
#       include <stdio.h>
#endif

#include <tools/debug.h> /* For P() macro used in l.h and below		*/
#include <tools/l.h>	 /* Prototoyptes for the ii_ functions.		*/

#ifdef __TURBOC__	 /* Turn off the "unreachable code" messages	*/
#pragma warn -rch	 /* generated by break statements that follow	*/
#endif		 /* user-supplied returns in lex actions.	*/

#ifdef YYDEBUG
	int	yydebug = 0;
#	define YY_D(x) if( yydebug ){ x; }else
#else
#	define YY_D(x)
#endif

typedef unsigned char	YY_TTYPE;

#define YYF		(( YY_TTYPE )(-1))

unsigned char	*ii_text();

/*----------------------------------------------------
 * The Yy_cmap[] and Yy_rmap arrays are used as follows:
 * 
 *  next_state= Yydtran[ Yy_rmap[current_state] ][ Yy_cmap[input_char] ];
 * 
 * Character positions in the Yy_cmap array are:
 * 
 *    ^@  ^A  ^B  ^C  ^D  ^E  ^F  ^G  ^H  ^I  ^J  ^K  ^L  ^M  ^N  ^O
 *    ^P  ^Q  ^R  ^S  ^T  ^U  ^V  ^W  ^X  ^Y  ^Z  ^[  ^\  ^]  ^^  ^_
 *         !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
 *     0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
 *     @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
 *     P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
 *     `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
 *     p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   DEL
 */

YYPRIVATE YY_TTYPE  Yy_cmap[128] =
{
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
};

YYPRIVATE YY_TTYPE  Yy_rmap[2] =
{
       0,  1
};

YYPRIVATE YY_TTYPE Yy_nxt[ 2 ][ 2 ]=
{
/* 00 */ (  -1,  -1 ),
/* 01 */ (  -1,  -1 ) 
};

/*----------------------------------------------------
 * yy_next(state,c) is given the current state number and input
 * character and evaluates to the next state.
 */

#define yy_next(state,c) (Yy_nxt[ Yy_rmap[state] ][ Yy_cmap[c] ])

/*----------------------------------------------------
 * The Yyaccept array has two purposes, If Yyaccept[i] is 0 then state
 * i is nonaccepting. If it's nonzero then the number determines whether
 * the string is anchored, 1=anchored at start of line,2=at end of line,
 * 3=both,4=line not anchored
 */

YYPRIVATE YY_TTYPE Yyaccept[] =
{
	0 ,    /* State 0   */
	0      /* State 1   */
};


#line 49 "../lex.par"


#line 55 "../lex.par"


/*-----------------------------------------------------------------
 * Global variables used by the parser.
 */

char   *yytext;		/* Pointer to lexeme.           */
int    	yyleng;		/* Length of lexeme.            */
int    	yylineno;	/* Input line number.           */
FILE	*yyout = stdout;

/*-----------------------------------------------------------------
 * Macros that duplicate functions in UNIX lex:
 */

#define output(c)   putc(c,yyout)
#define ECHO        fprintf(yyout, "%s", yytext )

#ifndef YYERROR
#    define YYERROR printf
#endif

#define yymore()    yymoreflg = 1

#define unput(c)  (ii_unput(c), --yyleng )
#define yyless(n) (    ii_unterm(), \
		     ( yyleng -= ii_pushback(n) ? n : yyleng ), \
		       ii_term() \
		  )

int  input P(( void ))		/* This is a macro in UNIX lex 	    */
{				/* P() is defined in tools/debug.h  */
    int c;

    if( (c = ii_input()) && (c != -1))
    {
	yytext   = (char *) ii_text();
	yylineno = ii_lineno();
	++yyleng;
    }
    return c;
}

/*----------------------------------------------------------------------*/

yylex()
{
    int        yymoreflg;         /* Set when yymore() is executed       */
    static int yystate   = -1;    /* Current state.                      */
    int        yylastaccept;      /* Most recently seen accept state     */
    int        yyprev;            /* State before yylastaccept           */
    int        yynstate;          /* Next state, given lookahead.        */
    int        yylook;            /* Lookahead character	         */
    int	       yyanchor;	  /* Anchor point for most recently seen */
				  /* accepting state.			 */
    if( yystate == -1 )
    {
	yy_init_lex();		/* One-time initializations */
        ii_advance();
        ii_pushback(1);
    }

    yystate      = 0;		/* Top-of-loop initializations */
    yylastaccept = 0;
    yymoreflg    = 0;
    ii_unterm();
    ii_mark_start();

    while( 1 )
    {
	/* Check end of file. If there's an unprocessed accepting state,
	 * yylastaccept will be nonzero. In this case, ignore EOF for now so
	 * that you can do the accepting action; otherwise, try to open another
	 * file and return if you can't.
	 */


	while( 1 )
	{
	    if( (yylook=ii_look(1)) != EOF )
	    {
		yynstate = yy_next( yystate, yylook );
		break;
	    }
	    else
	    {
		if( yylastaccept )		/* still something to do */
		{
		    yynstate = YYF;
		    break;
		}
		else if( yywrap() )    		/* another file?  */
		{      	            		/* no             */
		     yytext = "";
		     yyleng = 0;
		     return 0;
		}
		else
		{
		    ii_advance(); 		/* load a new buffer */
		    ii_pushback(1);
		}
	    }
	}


        if( yynstate != YYF )
        {
	    YY_D( printf("    Transition from state %d", yystate )     );
	    YY_D( printf(" to state %d on <%c>\n",   yynstate, yylook) );

            if( ii_advance() < 0 )               	    /* Buffer full */
            {
                YYERROR( "Line %d, lexeme too long. "
		         "Discarding extra characters.\n", ii_lineno() );
                ii_flush(1);
            }

            if(yyanchor = Yyaccept[ yynstate ])	   /* saw an accept state */
            {
		yyprev       = yystate  ;
		yylastaccept = yynstate ;
		ii_mark_end();  	/* Mark input at current character. */
			        	/* A subsequent ii_to_mark()        */
			        	/* returns us to this position.     */
            }

            yystate = yynstate;
        }
	else
        {
	    if( !yylastaccept )	   			  /* illegal input */
	    {
#ifdef YYBADINP
		YYERROR( "Ignoring bad input\n" );
#endif
		ii_advance();          /* Skip char that caused failure.   */
	    }
	    else
	    {
		ii_to_mark();          /* Back up to previous accept state */
		if( yyanchor & 2 )     /* If end anchor is active	   */
		    ii_pushback(1);    /* push back the CR or LF	   */

		if( yyanchor & 1 )		/* if start anchor is active */
		    ii_move_start();		/* skip the leading newline  */

		ii_term();              	/* Null-terminate the string */
		yytext   = (char *) ii_text();
		yyleng   = ii_length ();
		yylineno = ii_lineno ();

		YY_D( printf("Accepting state %d, ", yylastaccept )	);
		YY_D( printf("line %d: <%s>\n",      yylineno, yytext )	);

		switch( yylastaccept )
		{

#line 213 "../lex.par"


#line 219 "../lex.par"










		default:
		    YYERROR("INTERNAL ERROR, yylex: Unknown accept state %d.\n",
								yylastaccept );
		    break;
		}
	    }

	    ii_unterm();
	    yylastaccept = 0;

	    if( !yymoreflg )
	    {
		yystate = 0;
		ii_mark_start();
	    }
	    else
	    {
		yystate   = yyprev;  	/* Back up */
		yymoreflg = 0;
	    }
        }
    }
}

#line 147 "../c.lex"

/*------------------------------------------------------------------*/
typedef struct		/* Routines to recognize keywords. A table	*/
{			/* lookup is used for this purpose in order to	*/
    char  *name;	/* minimize the number of states in the FSM. A	*/
    int   val;		/* KWORD is a single table entry.		*/
}
KWORD;

KWORD  Ktab[] =			/* Alphabetic keywords	*/
{
    { "auto",     CLASS         },
    { "break",    BREAK         },
    { "case",     CASE          },
    { "char",     TYPE          },
    { "continue", CONTINUE      },
    { "default",  DEFAULT       },
    { "do",       DO            },
    { "double",   TYPE          },
    { "else",     ELSE          },
    { "enum",     ENUM          },
    { "extern",   CLASS         },
    { "float",    TYPE          },
    { "for",      FOR           },
    { "goto",     GOTO          },
    { "if",       IF            },
    { "int",      TYPE          },
    { "long",     TYPE          },
    { "register", CLASS         },
    { "return",   RETURN        },
    { "short",    TYPE          },
    { "sizeof",   SIZEOF        },
    { "static",   CLASS         },
    { "struct",   STRUCT        },
    { "switch",   SWITCH        },
    { "typedef",  CLASS         },
    { "union",    STRUCT        },
    { "unsigned", TYPE          },
    { "void",     TYPE          },
    { "while",    WHILE         }
};

static int cmp( a, b )
KWORD   *a, *b;
{
    return strcmp( a->name, b->name );
}

static int id_or_keyword( lex )	/* Do a binary search for a */
char    *lex;			/* possible keyword in Ktab */
{				/* Return the token if it's */
    KWORD         *p;		/* in the table, NAME       */
    KWORD         dummy;	/* otherwise.		    */

    dummy.name = lex;
    p = (KWORD *) bsearch( &dummy, Ktab, sizeof(Ktab)/sizeof(KWORD),
								sizeof(KWORD),
	BCC ((int _Cdecl(*)   (const void _FAR *, const void _FAR *)))
	MSC ((int  (__cdecl *)(const void *,      const void      *))) cmp );

    if( p )						/* It's a keyword. */
    {
	yylval.ascii = *yytext;
	return p->val;
    }
    else if( yylval.p_sym = (symbol *) findsym( Symbol_tab, yytext ) )
	return (yylval.p_sym->type->tdef) ? TTYPE : NAME ;
    else
	return NAME;
}
#ifdef TEST_LEX
ptok( int tok  )
{
	switch( tok )
	{
	case STRING:	printf("STRING (%s)\n",	yytext );	break;
	case ICON:	printf("ICON (%s)\n",	yytext );	break;
	case FCON:	printf("FCON (%s)\n",	yytext );	break;
	case TYPE:	printf("TYPE (%s)\n",	yytext );	break;
	case STRUCT:	printf("STRUCT (%s)\n",	yytext );	break;
	case ENUM:	printf("ENUM (%s)\n",	yytext );	break;
	case RETURN:	printf("RETURN (%s)\n",	yytext );	break;
	case GOTO:	printf("GOTO (%s)\n",	yytext );	break;
	case IF:	printf("IF (%s)\n",	yytext );	break;
	case ELSE:	printf("ELSE (%s)\n",	yytext );	break;
	case SWITCH:	printf("SWITCH (%s)\n",	yytext );	break;
	case CASE:	printf("CASE (%s)\n",	yytext );	break;
	case DEFAULT:	printf("DEFAULT (%s)\n",yytext );	break;
	case BREAK:	printf("BREAK (%s)\n",	yytext );	break;
	case CONTINUE:	printf("CONTINUE (%s)\n",yytext );	break;
	case WHILE:	printf("WHILE (%s)\n",	yytext );	break;
	case DO:	printf("DO (%s)\n",	yytext );	break;
	case FOR:	printf("FOR (%s)\n",	yytext );	break;
	case LC:	printf("LC (%s)\n",	yytext );	break;
	case RC:	printf("RC (%s)\n",	yytext );	break;
	case SEMI:	printf("SEMI (%s)\n",	yytext );	break;
	case ELLIPSIS:	printf("ELLIPSIS (%s)\n",yytext );	break;
	case COMMA:	printf("COMMA (%s)\n",	yytext );	break;
	case EQUAL:	printf("EQUAL (%s)\n",	yytext );	break;
	case ASSIGNOP:	printf("ASSIGNOP (%s)\n",yytext );	break;
	case QUEST:	printf("QUEST (%s)\n",	yytext );	break;
	case COLON:	printf("COLON (%s)\n",	yytext );	break;
	case OROR:	printf("OROR (%s)\n",	yytext );	break;
	case ANDAND:	printf("ANDAND (%s)\n",	yytext );	break;
	case OR:	printf("OR (%s)\n",	yytext );	break;
	case XOR:	printf("XOR (%s)\n",	yytext );	break;
	case AND:	printf("AND (%s)\n",	yytext );	break;
	case EQUOP:	printf("EQUOP (%s)\n",	yytext );	break;
	case RELOP:	printf("RELOP (%s)\n",	yytext );	break;
	case SHIFTOP:	printf("SHIFTOP (%s)\n",yytext );	break;
	case PLUS:	printf("PLUS (%s)\n",	yytext );	break;
	case MINUS:	printf("MINUS (%s)\n",	yytext );	break;
	case STAR:	printf("STAR (%s)\n",	yytext );	break;
	case DIVOP:	printf("DIVOP (%s)\n",	yytext );	break;
	case SIZEOF:	printf("SIZEOF (%s)\n",	yytext );	break;
	case UNOP:	printf("UNOP (%s)\n",	yytext );	break;
	case INCOP:	printf("INCOP (%s)\n",	yytext );	break;
	case LB:	printf("LB (%s)\n",	yytext );	break;
	case RB:	printf("RB (%s)\n",	yytext );	break;
	case LP:	printf("LP (%s)\n",	yytext );	break;
	case RP:	printf("RP (%s)\n",	yytext );	break;
	case STRUCTOP:	printf("STRUCTOP (%s)\n",yytext );	break;
	case TTYPE:	printf("TTYPE (%s)\n",	yytext );	break;
	case CLASS:	printf("CLASS (%s)\n",	yytext );	break;
	case NAME:	printf("NAME (%s)\n",	yytext );	break;
	}
}
#endif

